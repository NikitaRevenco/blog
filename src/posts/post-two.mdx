---
title: okie dokie
date: 2022-03-11
excerpt: This is my first post
tags: [next.js, blog, static blog, tailwind, mdx]
---

### Download

1. Download the `.iso`, `.iso.sig`, `b2sums.txt`, and `sha256sums.txt` files from the Arch Linux install page (Arch Linux > Download > Worldwide > geo.mirror.pkgbuild.com).

### Security

#### Verify the Hash Sum of the Image:

```sh title="file"
# In the same folder as the .iso
# In the same folder as the .iso
# In the same folder as the .iso
# Expected output: OK
b2sum -c b2sums.txt --ignore-missing

# Expected output: OK
sha256sum -c sha256sums.txt --ignore-missing

# Download and import the public key to verify the signature
gpg --auto-key-locate clear,wkd -v --locate-external-key pierre@archlinux.org
gpg --verify archlinux.iso.sig
```

### Flashing

Just use `cp` (assuming you want to flash to `/dev/sdc`):

```
sudo cp path/to.iso /dev/sdc
```

## Installing Arch

Boot from the USB stick into the Arch ISO installer.

### Keyboard Layout (Optional)

```bash
localectl list-keymaps # Find all keyboard layouts.
loadkeys us # This is the default.
```

### Setting Up an Internet Connection

#### Connecting via Ethernet Cable

Plug an ethernet cable in; the internet should work out of the box.

#### Connecting via Wi-Fi

```bash
iwctl
device list # Choose the station/device name to
station foo connect bar

# Verify internet connection, ensure you receive Verify internet connection, ensure you receive Verify internet connection, ensure you receive
ping -c 4 archlinux.org
exit
```


```js showLineNumbers
console.log('Hello, World!'); console.log('Hello, World!'); console.log('Hello, World!'); console.log('Hello, World!'); console.log('Hello, World!');
console.log('Hello, World!'); console.log('Hello, World!'); console.log('Hello, World!'); console.log('Hello, World!'); console.log('Hello, World!');
console.log('Hello, World!'); console.log('Hello, World!'); console.log('Hello, World!'); console.log('Hello, World!'); console.log('Hello, World!');
console.log('Hello, World!'); console.log('Hello, World!'); console.log('Hello, World!'); console.log('Hello, World!'); console.log('Hello, World!');
```

```js
const sum = (a, b) => a + b;

console.log(sum(5, 3)); // 8
```

```js "factorial" "function" "===" "console" "5" "{"
function factorial(n) {
    if (n === 0) return 1;
    return n * factorial(n - 1);
}

console.log(factorial(5)); // 120
```

```js "Animal"
class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log(`${this.name} makes a sound.`);
    }
}

class Dog extends Animal {
    speak() {
        console.log(`${this.name} barks.`);
    }
}

const dog = new Dog('Rex');
dog.speak(); // Rex barks.
```

```js
function debounce(fn, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn(...args), delay);
    };
}

const saveInput = debounce(() => console.log('Input saved!'), 500);
document.querySelector('input').addEventListener('input', saveInput);
```

### Setting Up the Partitions

Get the names of the blocks

```
$ lsblk
```

For both partition setups, you'll want to setup a table on your primary drive.

```
$ gdisk /dev/block_name
```

Inside of gdisk, you can print the table using the `p` command.

To create a new partition use the `n` command. `d` to delete. The below table shows
the disk setup I have for my primary drive

| partition | first sector | last sector | code |
| --------- | ------------ | ----------- | ---- |
| 1 (efi)   | default      | +512M       | ef00 |
| 2 (boot)  | default      | +4G         | ef02 |
| 3 (root)  | default      | default     | 8309 |

If you have a second drive for your home disk, then your table would be as
follows.

| partition | first sector | last sector | code |
| --------- | ------------ | ----------- | ---- |
| 1 (home)  | default      | default     | 8302 |

When done setting up the partitions, `w` to write.

#### Encrypt the Partitions

Make sure the encryption modules are loaded.

#### Group Highlighted Chars By Id

Place an id after `#` after the chars. This allows you to color chars
differently based on their id.

````md
```js /age/
const [age, setAge] = useState(50);
const [name, setName] = useState("Taylor");
```
````

```js "Taylor"
const [age, setAge] = useState(50);
const [name, setName] = useState("Taylor");
```

**Styling**: The chars `<span>{:html}` receives a `data-chars-id="<id>"`
attribute to style via CSS.

#### Highlight Inline Code

Append `\{:lang}` (e.g. `\{:js}`) to the end of inline code to highlight it like
a regular code block.

```md
This is an array `[1, 2, 3]{:js}` of numbers 1 through 3.
```

---

```bash
modprobe dm-crypt
modprobe dm-mod
```

Setting up encryption on our luks lvm partiton

```bash
cryptsetup luksFormat -v -s 512 -h sha512 /dev/a...3 # root
```

If you have a home partition:

```bash
cryptsetup luksFormat -v -s 512 -h sha512 /dev/b...1 # home
```

Mount the drives:

```bash
cryptsetup open /dev/a...3 luks_lvm # root
```

If you have a home parition:

```bash
cryptsetup open /dev/b...1 arch-home # home
```

### Volume setup

Create the volume and volume group

```bash
pvcreate /dev/mapper/luks_lvm

vgcreate arch /dev/mapper/luks_lvm
```

Create a volume for your swap space. A good size for this is your RAM size (find out with `free -h`) + 2GB.

```bash
lvcreate -n swap -L 18G arch
```

Next you have a few options depending on your setup

### Single Disk

If you have a single disk, you can either have a single volume for your root
and home, or two separate volumes.

#### No home partition

Single volume is the most straightforward. To do this, just use the entire
disk space for your root volume

```bash
lvcreate -n root -l +100%FREE arch
```

#### With home partition

For two volumes, you'll need to estimate the max size you want for either your
root or home volumes. With a root volume of 200G, this looks like:

```bash
lvcreate -n root -L 200G arch
```

Then use remaining disk space for home

```bash
lvcreate -n home -l +100%FREE arch
```

## Filesystems

FAT32 on EFI partiton

```bash
mkfs.fat -F32 /dev/a...1
```

EXT4 on Boot partiton

```bash
mkfs.ext4 /dev/a...2
```

BTRFS on root

```bash
mkfs.btrfs -L root /dev/mapper/arch-root
```

BTRFS on home if exists

```bash
mkfs.btrfs -L home /dev/mapper/arch-home
```

Setup swap device

```bash
mkswap /dev/mapper/arch-swap
```

### Mounting

Mount swap

```bash
swapon /dev/mapper/arch-swap
swapon -a
```

Mount root

```bash
mount /dev/mapper/arch-root /mnt
```

Create boot

```bash
mkdir -p /mnt/boot
```

If you have a home:

```bash
mkdir -p /mnt/home
```

Mount the boot partiton

```bash
mount /dev/a...2 /mnt/boot
```

Mount the home partition if you have one, otherwise skip this

```bash
mount /dev/mapper/arch-home /mnt/home
```

Create the efi directory

```bash
mkdir /mnt/boot/efi
```

Mount the EFI directory

```bash
mount /dev/a...1 /mnt/boot/efi
```

### Install arch

```bash
pacstrap -K /mnt base base-devel linux linux-firmware neovim btrfs-progs lvm2 grub efibootmgr zsh sof-firmware
```

Load the file table

```bash
genfstab -U -p /mnt > /mnt/etc/fstab
```

chroot into your installation

```bash
arch-chroot /mnt /bin/bash
```

## Configuring

### Decrypting volumes

Add `encrypt` and `lvm2` into the hooks array between `block` and `filesystems` in `/etc/mkinitcpio.conf`:

### Bootloader

Setup grub on efi partition

```bash
grub-install --efi-directory=/boot/efi
```

```bash
nvim /etc/default/grub
```

Append the following kernel parameters to the env variable `GRUB_CMDLINE_LINUX_DEFAULT`
You can fill in the `<uuid>` by typing `:r !blkid /dev/a...3`

```bash
root=/dev/mapper/arch-root cryptdevice=UUID=<uuid>:luks_lvm
```

### Keyfile

```bash
mkdir /secure
```

Root keyfile

```bash
dd if=/dev/random of=/secure/root_keyfile.bin bs=512 count=8
```

Home keyfile if home partition exists

```bash
dd if=/dev/random of=/secure/home_keyfile.bin bs=512 count=8
```

Change permissions on these

```bash
chmod 000 /secure/*
chmod 600 /boot/initramfs-linux*
```

Add to partitions

```bash
cryptsetup luksAddKey /dev/a...3 /secure/root_keyfile.bin

# skip below if using single disk
cryptsetup luksAddKey /dev/b...1 /secure/home_keyfile.bin
```

```bash
nvim /etc/mkinitcpio.conf
```

Add this:

```bash
FILES=(/secure/root_keyfile.bin)
```

### Home Partition Crypttab (Skip if single disk)

Open up the crypt table.

```bash
nvim /etc/crypttab
```

Add in the following line at the bottom of the table
You can get `<uuid>` by `:r !blkid /dev/b...1`

```bash
arch-home      UUID=<uuid>    /secure/home_keyfile.bin
```

### Grub

Reload linux

```bash
mkinitcpio -p linux
```

Create grub config

```bash
grub-mkconfig -o /boot/grub/grub.cfg
grub-mkconfig -o /boot/efi/EFI/arch/grub.cfg
```

### System Configuration

#### Timezone

```bash
ln -sf /usr/share/zoneinfo/Europe/London /etc/localtime
```

#### NTP

```bash
nvim /etc/systemd/timesyncd.conf
```

Add in the NTP servers

```bash
[Time]
NTP=0.arch.pool.ntp.org 1.arch.pool.ntp.org 2.arch.pool.ntp.org 3.arch.pool.ntp.org
FallbackNTP=0.pool.ntp.org 1.pool.ntp.org
```

Enable timesyncd

```bash
systemctl enable systemd-timesyncd.service
```

Network manager

```bash
pacman -S networkmanager && systemctl enable NetworkManager.service
```

#### Locale

Uncomment the UTF8 lang you want:

```bash
nvim /etc/locale.gen
```

```bash
locale-gen
```

If you changed your keyboard layout:

```bash
echo "KEYMAP=us" > /etc/vconsole.conf
```

```bash
echo "LANG=en_GB.UTF-8" > /etc/locale.conf
```

#### hostname

```bash
echo "arch" > /etc/hostname
```

#### Users

First secure the root user by setting a password

```bash
passwd
```

Add a new user as follows

```bash
useradd -m -k /usr/share/misc -G wheel -s /bin/zsh nikita
```

set the password on the user

```bash
passwd nikita
```

Add the wheel group to sudoers

```bash
EDITOR=nvim visudo
```

Uncomment this line:

```bash
%wheel ALL=(ALL:ALL) ALL
```

### Reflector

Edit `/etc/xdg/reflector/reflector.conf` to use this config:

```sh
--save /etc/pacman.d/mirrorlist
--protocol https
--country "United Kingdom"
--latest 5
--sort rate
```
Enable reflector service:

```sh
systemctl enable --now reflector.service
systemctl enable --now reflector.timer
```

### Microcode

Install amd or intel microcode depending on which processor you use (find out with `lscpu`):

```sh
pacman -S amd-ucode # or intel-ucode
```

### Firewall

```bash
pacman -S ufw
```

```bash
systemctl enable --now ufw.service
ufw enable
ufw limit SSH
ufw logging off
```

### Trim

If you are using SSD, setup trim

```bash
systemctl enable fstrim.timer
```

### Secure boot

Before creating new keys and modifying EFI variables, it is advisable to backup the current variables, so that they may be restored in case of error.

```bash
pacman -S efitools && for var in PK KEK db dbx ; do efi-readvar -v $var -o old_${var}.esl ; done
```

```bash
exit
umount -R /mnt
reboot now
```

Now reboot into `UEFI` and put secure boot into **SETUP MODE**. Refer to your motherboard manufaturer's guide on how to do that.

For most systems, you can do this by, just going into **BOOT** tab, **enabling secure boot**, go to **SECURITY** tab and do **Erase all secure boot settings**.

Now save changes and exit.

After enabling Setup Mode, reboot again, which allows the system to clear any previous Secure Boot keys.

Now when booting into **Arch Linux** you'll be prompted to enter the passphrase to your LUKS partition.

Enter it and boot into the system. Login as **root**.

```bash
pacman -S sbctl
```

Check status

```bash
sbctl status
```

You should see that sbctl is not installed and secure boot is disabled.

```bash
sbctl create-keys
sbctl enroll-keys -m
```

Check status again

```bash
sbctl status
```

sbctl should be installed now, but secure boot will not work until the boot files have been signed with the keys you just created. 

```bash
sbctl verify
```

Now sign all the unsigned files. Usually the kernel and the boot loader need to be signed. For example: 

```bash
sbctl sign -s /boot/vmlinuz-linux
sbctl sign -s /boot/EFI/BOOT/BOOTX64.EFI
# ...
```

```bash
mkinitcpio -P
```

### Introduction

Tracking down and fixing both errors and unexpected behavior in your code is an inevitable part of being a developer. The art of finding the cause of problems and then fixing them in code is known as **debugging**. The [origin of the term "debugging"](https://en.wikipedia.org/wiki/Debugging#Etymology) is a classic computer science tale worth reading if you haven’t already.

In this lesson, we'll cover all of the main techniques you can use to debug your code when you run into a problem.

### Lesson overview

This section contains a general overview of topics that you will learn in this lesson.

- What a stack trace is.
- Using a stack trace to debug your code.
- Using `puts`, `p`, Pry and debug gem's VSCode integration to debug your code.
- How you should decide to start with debugging.

### Reading the stack trace

When your Ruby program crashes after encountering a runtime error or exception, it will produce a wall of text known as a **stack trace** that is then output in your terminal. A stack trace looks something like this:

Don't let the stack trace intimidate you. You don't need to read it all or even know what most of it means.

The stack trace prints each line of code in your program that was executed before it crashed. <span id='most-useful-stack-trace-line'>The very first line of the stack trace</span> will generally provide the most useful information about the error your program encountered:

<span id="stack-trace-first-line-info">
  First, this line of the stack trace will tell you what specific line caused
  the runtime error. In the above example, the error was encountered in line 31
  of the file `bottles.rb`. This line also provides a brief explanation of the
  error and the name of the error. (In this case, it's a
  [`NameError`](https://docs.ruby-lang.org/en/3.3/NameError.html)). And yes, in
  Ruby, [errors (Exceptions) are also
  objects](https://docs.ruby-lang.org/en/3.3/Exception.html).
</span>

There you have it. At this point, you know where in your code the exception is being raised, and you know the type of error you're dealing with. You might even know what fixes need to be implemented in your code.

But what if you don't know how to fix your code? Then it's time to dive into debugging!

### Debugging with puts

The debugging process is all about confirming assumptions about your code until you find something that goes against your assumptions. For example, does a variable or method return what you expect? Does a calculation or iteration over an array or hash give the output you expect?

The easiest and quickest way to confirm your assumptions while debugging is by using `puts` statements to output the return value of variables, methods, calculations, iterations, or even entire lines of code to your terminal.

Let's say that for _whatever_ reason, we need to write a method that takes a string and checks if the string is an **isogram** (a word that has no repeating letters) or not. Perhaps it's a hostage situation that requires a pro debugger? Let's take a look at a first draft:

```css {1-11} showLineNumbers
code[data-line-numbers] {
  counter-reset: line;
}

code[data-line-numbers] > [data-line]::before {
  counter-increment: line;
  content: counter(line);

  /* Other styling */
  display: inline-block;
  width: 0.75rem;
  margin-right: 2rem;
  text-align: right;
  color: gray;
}

code[data-line-numbers-max-digits="2"] > [data-line]::before {
  width: 1.25rem;
}

code[data-line-numbers-max-digits="3"] > [data-line]::before {
  width: 1.75rem;
}

code[data-line-numbers-max-digits="4"] > [data-line]::before {
  width: 2.25rem;
}
```

Okay, that didn't work. We didn't expect that. Why? Because the string _Odin_ is an isogram but we got `false`. The method didn't throw an exception, so we don't even have a line to start debugging at. Now what?

We know that `original_length == unique_length` returns `false` since it's the last statement, so why not place a `puts` on the line before that to see what `unique_length` is. As an alternative to `puts`, `p` is also commonly used for debugging; `p` is a combination of `puts` and `inspect` (more on that below). To better show the differences between what Ruby is printing to the terminal and returning, the examples in this section use the full IRB syntax, which is exactly what you'd see if you typed these commands into your own terminal IRB session.

```ruby
irb(main):001:1* def isogram?(string)
irb(main):002:1*   original_length = string.length
irb(main):003:1*   string_array = string.downcase.split
irb(main):004:1*   unique_length = string_array.uniq.length
irb(main):005:1*
irb(main):006:1*   p unique_length
irb(main):007:1*
irb(main):008:1*   original_length == unique_length
irb(main):009:0> end
=> :isogram?
irb(main):010:0> isogram?("Odin")
1
=> false
```

_INTERESTING_. Using `p` on `unique_length` prints it to the console and shows us something must be wrong with how we called `#uniq` on `string_array` because we know that we have `4` unique characters in our input but we got `1` as output. For verification, let's place another `p` statement before the `unique_length` statement:

```ruby
irb(main):001:1* def isogram?(string)
irb(main):002:1*   original_length = string.length
irb(main):003:1*   string_array = string.downcase.split
irb(main):004:1*
irb(main):005:1*   p string_array
irb(main):006:1*
irb(main):007:1*   unique_length = string_array.uniq.length
irb(main):008:1*
irb(main):009:1*   p unique_length
irb(main):010:1*
irb(main):011:1*   original_length == unique_length
irb(main):012:0> end
=> :isogram?
irb(main):013:0> isogram?("Odin")
["odin"]
1
=> false
```

Indeed, we didn't use `#split` correctly, as it creates an array with the given string rather than an array of the string's characters. Why? By default, if we didn’t provide arguments, [the #split method](https://docs.ruby-lang.org/en/3.3/String.html#method-i-split) will divide the string using `whitespace` as the delimiter. Try running the above code in a REPL or IRB using `#split('')` instead, and you'll see the difference.

Hostage situation resolved! That wasn't so bad, was it?

#### Debugging with puts and nil

Using `puts` is a great way to debug, but there's a **HUGE** caveat with using it: calling `puts` on anything that is `nil` or an empty string or collection will just print a blank line to your terminal.

This is one instance where using `p` will yield more information. As mentioned above, `p` is a combination of puts and [the #inspect method](https://docs.ruby-lang.org/en/3.3/Object.html#method-i-inspect), the latter of which essentially prints a string representation of whatever it's called on. To illustrate this, try the following in a REPL:

```ruby
puts "Using puts:"
puts []
p "Using p:"
p []
```

### Debugging with Pry-byebug

[Pry](https://github.com/pry/pry) is a Ruby gem that provides you with an interactive [REPL](https://www.rubyguides.com/2018/12/what-is-a-repl-in-ruby/) while your program is running. The REPL provided by Pry is very similar to IRB but has added functionality. The recommended Ruby gem for debugging is [Pry-byebug](https://github.com/deivid-rodriguez/pry-byebug) and it includes Pry as a dependency. Pry-byebug adds step-by-step debugging and stack navigation.

To use Pry-byebug, you'll first need to install it in your terminal by running `gem install pry-byebug`. You can then make it available in your program by requiring it at the top of your file with `require 'pry-byebug'`. Finally, to use Pry-byebug, you just need to call `binding.pry` at any point in your program.

To follow along with these examples save the code into a Ruby file (e.g., `script.rb`) and then run the file in your terminal (e.g., `ruby script.rb`)

```ruby
require 'pry-byebug'

def isogram?(string)
  original_length = string.length
  string_array = string.downcase.split

  binding.pry

  unique_length = string_array.uniq.length
  original_length == unique_length
end

isogram?("Odin")
```

When your code executes and gets to `binding.pry`, it will open an IRB-like session in your terminal. You can then use that session to check the values of anything within the scope of where you included `binding.pry`. However, keep in mind that any code written _after_ the `binding.pry` statement will not have been evaluated during the Pry session.

For example, here `original_length` and `string_array` are in scope. However, `unique_length` is not in scope, because it is written after `binding.pry` and has not been evaluated yet.

Thus, adding a `binding.pry` line in our code is similar to creating a breakpoint in JavaScript.

To see this point in action, try running the following:

```ruby
require 'pry-byebug'

def yell_greeting(string)
  name = string

  binding.pry

  name = name.upcase
  greeting = "WASSAP, #{name}!"
  puts greeting
end

yell_greeting("bob")
```

During the session, if you check for the value of `name`, you will notice that you get back the value `bob` instead of `BOB`. What value do you think `greeting` will return? Yup, it will be `nil`. This is because `name = name.upcase` and `greeting = "WASSAP, #{name}!"` occurred after the `binding.pry` call and were never evaluated.

Using the same example above, you can use one of pry-byebug's commands to figure out what `name = name.upcase` will return. You won't need to quit the session or add another `binding.pry` beneath it. Enter `next` to step over to the next line.

```ruby
[1] pry(main)> name
=> "bob"
[2] pry(main)> greeting
=> nil
[3] pry(main)> next

     5: def yell_greeting(string)
     6:   name = string
     7:
     8:   binding.pry
     9:
    10:   name = name.upcase
 => 11:   greeting = "WASSAP, #{name}!"
    12:   puts greeting
    13: end

[4] pry(main)> name
=> "BOB"

```

It stops after evaluating the next line. `name` now returns `BOB`. Calling `next` again will evaluate the following line. Try it out to know what `greeting` will return. [Pry-byebug has a few more commands](https://github.com/deivid-rodriguez/pry-byebug). Play around with them to get a feel of what they do.

As you can see, using Pry-byebug for debugging achieves the same outcome as `puts` debugging: it allows you to confirm the assumptions you have about particular parts of your code. If your code is complex, Pry-byebug will probably allow you to debug quicker thanks to its interactive runtime environment. In such scenarios, Pry-byebug will be easier to interact with than having to add `puts` statements everywhere and re-running your code each time.

There is far, far more that you can do with Pry-byebug, but that's beyond the scope of this lesson. Check out the Assignments and Additional Resources to find out where you can learn more about this useful gem.

### How to start debugging

<Note title="How do we do it?">

Programs generally go wrong due to two main reasons:

1. The program encounters an error and won't run. For example, a typo may cause a syntax error to be raised that causes the program to crash. In this case, Ruby provides a stack trace.

1. The program runs but does not work the way you expect. For example, you expect a method to return a `2`, but it actually returns `6` when you run it. In this case, there is no stack trace.


```jsx /aside/ {3}
export function Note({ children }) {
  return (
    <aside className="-mx-4 my-4 block overflow-x-auto">
      {children}
    </aside>
  );
}
```

Obviously, if available, <span id='debugging-with-stack-trace'>the stack trace is the first place you should look when debugging.</span> <span id='debugging-without-stack-trace'>If there's no stack trace, then `puts` and Pry are the easiest and quickest tools you can use to get yourself back up and running.</span>

</Note>

### Assignment

1. Go through the Ruby Guides [Ruby Debugging](https://www.rubyguides.com/2015/07/ruby-debugging/) tutorial, which covers the same topics we went over, but in more depth.
1. Read through the [Exceptions and Stack Traces](https://launchschool.com/books/ruby/read/more_stuff#readingstacktraces) section of Launch School's online book _Introduction to Programming with Ruby_.
1. Check your [VSCode Extensions](https://code.visualstudio.com/docs/editor/extension-marketplace) and make sure the [Ruby LSP](https://marketplace.visualstudio.com/items?itemName=Shopify.ruby-lsp) and the [VSCode rdbg Ruby Debugger](https://marketplace.visualstudio.com/items?itemName=KoichiSasada.vscode-rdbg) extensions are installed.
1. Now that you're familiar with the basics, we're going to have some fun with VSCode! Check the [VSCode rdbg Ruby Debugger documentation](https://github.com/ruby/vscode-rdbg) and generate the configuration inside your VSCode by going to `Run and Debug` and clicking on `create a launch.json file` then picking `Ruby (rdbg)`. Now, the configuration you want to use is `Debug current file with rdbg` that you can see at the top of the Debug sidebar. You can also invoke the last used debugging configuration with `F5`. `launch.json` files need to be created on a per project basis. If you're having a hard time figuring out how to navigate to your `launch.json` file in order to change the configuration, peek into [Debugging with VScode launch configurations portion](https://code.visualstudio.com/docs/editor/debugging#_launch-configurations). We encourage you to go through the entire article, though!
1. Now that everything is installed, configured, let's create a new file which you can call `script.rb`. Next copy and paste the very first example in the [Debugging with pry-byebug](#debugging-with-pry-byebug) Section. Get rid of the `require pry-byebug` line and change `binding.pry` to `debugger`. Save the file.
1. Click the `Run and Debug` button, open up the folder your script is located in, set a VSCode breakpoint somewhere within the function, and Run the debugger! This should all look very familiar to you, when you hit the VSCode breakpoint it should look similar to the breakpoints you used in the [JavaScript Developer Tools lesson](https://www.theodinproject.com/lessons/foundations-javascript-developer-tools). But _whoa_, once we hit the `debugger` breakpoint we got an interactive REPL to play around with! The best of both worlds! Play around with this, and feel free to reference [Debugging with VScode documentation](https://code.visualstudio.com/docs/editor/debugging) if you get stuck.
1. Although VSCode's debugger is a helpful tool that can make debugging simpler, many companies won't be using it - and will want you to be familiar with debugging using the concepts this lesson focused on: the stack trace, `puts`,`debug`, `pry-byebug`. Let's practice them by completing the debugging exercises from the [ruby-exercises repo](https://github.com/TheOdinProject/ruby-exercises) that you previously cloned.

### Knowledge check

[`What is a stack trace?`](#reading-the-stack-trace)

The following questions are an opportunity to reflect on key topics in this lesson. If you can't answer a question, click on it to review the material, but keep in mind you are not expected to memorize or master this knowledge.

- [What is a stack trace?](#reading-the-stack-trace)
- [What is generally the most useful line in a stack trace?](#most-useful-stack-trace-line)
- [What are the two things you can learn from the first line of a stack trace?](#stack-trace-first-line-info)
- [How do `puts` and Pry help you in the debugging process?](#debugging-with-puts)
- [What should you use instead of `puts` for `nil` values?](#debugging-with-puts-and-nil)
- [Where should you start with debugging if you encounter a runtime error?](#debugging-with-stack-trace)
- [Where should you start with debugging if your program runs but does not work the way you expect?](#debugging-without-stack-trace)

### Additional resources

This section contains helpful links to related content. It isn't required, so consider it supplemental.

- Read through [HOWTO debug your Ruby code](https://readysteadycode.com/howto-debug-your-ruby-code), especially the first section on `puts` debugging, by ReadySteadyCode.
- Read the article on [Debugging without doom and gloom](https://practicingruby.com/articles/debugging-without-doom-and-gloom) by Practicing Ruby.
- Poke around [Debug's repo and its README](https://github.com/ruby/debug) that will help you master this invaluable gem.
- Watch [debug.gem: Ruby's new debug functionality talk by Koichi Sasada](https://www.youtube.com/watch?v=XeWHrsp6nwo), one of debug's maintainers to learn about its history and functionality.
- Read this brilliant article about [reading Ruby error messages](https://medium.com/@roni.shabo/overcoming-ruby-error-messages-ebf53928b64e).
